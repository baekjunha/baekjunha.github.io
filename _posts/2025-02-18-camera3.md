---
categories: graphics
tags: [graphics, opengl, camera, fps]
toc: true
toc_sticky: true
author_profile: false
use_math: true 
thumbnail: images/LookAtMat.png
---

## 마우스 입력  

**자료 출처**: [LearnOpenGL](https://learnopengl.com/)

yaw 및 pitch 값은 마우스(또는 컨트롤러/조이스틱) 움직임에서 얻어진다. 수평 마우스 움직임은 yaw에 영향을 주고 수직 마우스 움직임은 pitch에 영향을 준다. 아이디어는 마지막 프레임의 마우스 위치를 저장하고 현재 프레임에서 마우스 값이 얼마나 변경되었는지 계산하는 것이다. 수평 또는 수직 차이가 클수록 pitch 또는 yaw 값을 더 많이 업데이트하고 따라서 카메라가 더 많이 움직여야 한다.  
즉, 마우스의 움직임을 감지하여 그 움직임의 크기(변위)에 비례하여 카메라의 시선을 제어하는 방식이다.  

(비유하자면 자동차의 핸들과 같다. 핸들을 조금 돌리면 자동차가 조금만 방향을 바꾸고, 핸들을 많이 돌리면 자동차가 크게 방향을 바꾸는 것과 같은 원리인 것이다. 마우스는 핸들, 카메라는 자동차에 비유할 수 있다.)

먼저 GLFW에게 커서를 숨기고 캡처하도록 지시한다. 커서 캡처는 응용 프로그램이 포커스를 받으면 마우스 커서가 창 중앙에 유지된다는 의미이다(응용 프로그램이 포커스를 잃거나 종료하지 않는 한).  

우리가 `FPS(First-Person Shooter)` 게임을 할 때, 마우스 커서가 화면에 보이는 것을 원하지 않는다. 왜냐하면 커서가 있으면 조준점이 가려지고, 게임 몰입도가 떨어지기 때문이다. 또한, 마우스를 움직이다가 실수로 창 밖으로 커서가 나가버리면 게임 컨트롤이 엉망이 될 수 있다. 그래서 다음과 같은 숨기기, 캡쳐를 이용한다.  

```
커서 숨기기: 마우스 커서를 화면에서 보이지 않게 감춘다. 마치 투명 망토를 씌운 것처럼 말이다.

커서 캡처하기:

게임 창이 활성화되면 (포커스를 받으면), 마우스 커서가 창 중앙에 강제로 고정된다.

사용자가 마우스를 아무리 움직여도 커서는 창 밖으로 벗어나지 않는다. 마치 자석으로 붙잡아 놓은 것처럼 말이다.

만약 게임 창이 비활성화되면 (포커스를 잃으면), 커서 캡처가 해제되어 커서를 자유롭게 움직일 수 있다.
```





간단한 구성 호출로 이를 수행할 수 있다. 

```c++
glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
```
이 한 줄의 코드로 커서를 숨기고 캡처하는 모든 과정을 처리할 수 있다. GLFW 덕분에 우리는 복잡한 코드를 직접 작성할 필요 없이 편리하게 FPS 게임 카메라 시스템을 만들 수 있다.

이 호출 후에는 마우스를 어디로 움직이든 보이지 않으며 창을 벗어나지 않아야 한다. 이것은 FPS 카메라 시스템에 완벽하다.

pitch 및 yaw 값을 계산하려면 GLFW에게 마우스 움직임 이벤트를 수신하도록 지시해야 한다. 다음 프로토타입을 사용하여 콜백 함수를 만든다.

```c++
void mouse_callback(GLFWwindow* window, double xpos, double ypos);
```

여기서 `xpos`와 `ypos`는 현재 마우스 위치를 나타낸다. GLFW에 콜백 함수를 등록하는 즉시, 마우스가 움직일 때마다 `mouse_callback` 함수가 호출된다.

```c++
glfwSetCursorPosCallback(window, mouse_callback);
```

플라이 스타일 카메라에 대한 마우스 입력을 처리할 때 카메라의 방향 벡터(direction vector)를 완전히 계산하기 전에 몇 가지 단계를 거쳐야 한다.

1.  마지막 프레임 이후 마우스의 오프셋(변위)을 계산한다.
2.  오프셋(변위) 값을 카메라의 yaw 및 pitch 값에 추가한다.
3.  최소/최대 pitch 값에 대한 일부 제약 조건을 추가한다.
4.  방향 벡터를 계산한다.  

`1.마지막 프레임 이후 마우스의 오프셋(변위)을 계산한다.`  
첫 번째 단계는 마지막 프레임 이후 마우스의 오프셋(변위)을 계산하는 것이다. 먼저 마지막 마우스 위치를 응용 프로그램에 저장해야 하며, 초기에는 화면 중앙(화면 크기는 800 x 600라고 가정.)에 있도록 초기화한다.

```c++
float lastX = 400, lastY = 300;
```

그런 다음 마우스 콜백 함수에서 마지막 프레임과 현재 프레임 사이의 오프셋(변위) 움직임을 계산한다.

```c++
float xoffset = xpos - lastX;
float yoffset = lastY - ypos; // y 좌표 범위가 아래에서 위로이므로 반전된다.
lastX = xpos;
lastY = ypos;

const float sensitivity = 0.1f;
xoffset *= sensitivity;
yoffset *= sensitivity;
```

오프셋(변위) 값에 민감도 값을 곱한다. 이 곱셈을 생략하면 마우스 움직임이 너무 강해진다. 원하는 대로 민감도 값을 조정한다.

`2.다음으로, 오프셋(변위) 값을 전역적으로 선언된 pitch 및 yaw 값에 추가한다.`

```c++
yaw   += xoffset;
pitch += yoffset;
```

`3.최소/최대 pitch 값에 대한 일부 제약 조건을 추가한다.`  
세 번째 단계에서는 사용자가 이상한 카메라 움직임을 만들 수 없도록 (또한 방향 벡터가 세계 위쪽 방향과 평행해지면 LookAt 뒤집힘이 발생한다) 카메라에 몇 가지 제약 조건을 추가하려고 한다. pitch는 사용자가 89도 이상 (90도에서 LookAt 뒤집힘이 발생한다) 또는 -89도 아래를 볼 수 없도록 제약되어야 한다. 이렇게 하면 사용자가 하늘을 보거나 발 아래를 볼 수 있지만 더 이상(90도로는)은 볼 수 없다. 제약 조건은 제약 조건을 위반할 때마다 Euler 값을 제약 조건 값으로 대체하여 작동한다.

```c++
if(pitch > 89.0f)
  pitch =  89.0f;
if(pitch < -89.0f)
  pitch = -89.0f;
```

수평 회전에서 사용자를 제약하고 싶지 않으므로 yaw 값에 제약 조건을 설정하지 않는다. 그러나 원한다면 yaw에 제약 조건을 추가하는 것도 똑같이 쉽다.

`4.네 번째이자 마지막 단계는 실제 방향 벡터를 계산하는 것이다.`

```c++
glm::vec3 direction;
direction.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
direction.y = sin(glm::radians(pitch));
direction.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
cameraFront = glm::normalize(direction);
```

이 계산된 방향 벡터에는 마우스 움직임에서 계산된 모든 회전이 포함된다. `cameraFront` 벡터가 이미 glm의 `lookAt` 함수에 포함되어 있으므로 설정이 완료되었다.

이제 코드를 실행하면 카메라가 마우스 커서가 처음 포커스를 받을 때마다 갑자기 크게 점프하는 것을 알 수 있다(***갑작스러운 시점 점프***).  

 이러한 갑작스러운 점프의 원인은 커서가 창에 들어오자마자 마우스 콜백 함수가 마우스가 화면에 들어온 위치와 동일한 `xpos` 및 `ypos` 위치로 호출되기 때문이다. 이것은 종종 화면 중앙에서 상당히 멀리 떨어져 있는 위치이므로 큰 오프셋(변위)과 큰 움직임 점프가 발생한다.카메라 시점이 홱 돌아가는 현상이 발생하는 것이다.

이럴땐 전역 bool 변수를 정의하여 마우스 입력을 처음 받는 것인지 확인하여 이 문제를 해결할 수 있다. 처음인 경우 초기 마우스 위치를 새 `xpos` 및 `ypos` 값으로 업데이트한다. 결과적인 마우스 움직임은 새로 입력된 마우스의 위치 좌표를 사용하여 오프셋(변위)을 계산한다.

```c++
if (firstMouse) // 처음에는 true로 설정된다.
{
    lastX = xpos;
    lastY = ypos;
    firstMouse = false;
}
```

최종 코드는 다음과 같다.

```c++
void mouse_callback(GLFWwindow* window, double xpos, double ypos)
{
    if (firstMouse) //firstMouse가 True일 때 실행되는 조건문
    {
        lastX = xpos;
        lastY = ypos;
        //float lastX = 400, lastY = 300;였다. 즉 커서의 last위치를 중앙으로 바꿔줌. 
        firstMouse = false; //이후엔 상관없으니 false로 변경.
    }
  
    float xoffset = xpos - lastX;
    float yoffset = lastY - ypos; 
    lastX = xpos;
    lastY = ypos;

    float sensitivity = 0.1f;
    xoffset *= sensitivity;
    yoffset *= sensitivity;

    yaw   += xoffset;
    pitch += yoffset;

    if(pitch > 89.0f)
        pitch = 89.0f;
    if(pitch < -89.0f)
        pitch = -89.0f;

    glm::vec3 direction;
    direction.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
    direction.y = sin(glm::radians(pitch));
    direction.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
    cameraFront = glm::normalize(direction);
}
```

자, 이제 자유롭게 3D 장면을 이동할 수 있다!

## 줌

카메라 시스템에 약간의 추가 기능을 구현하여 줌 인터페이스를 구현한다. 이전 장에서 시야각(Field of view) 또는 fov가 장면에서 볼 수 있는 양을 크게 정의한다고 말했다. 시야각이 작아지면 장면의 투영 공간이 작아진다. 이 작은 공간은 동일한 NDC에 투영되어 확대하는 착시 효과를 준다. 확대하려면 마우스 스크롤 휠을 사용한다. 마우스 움직임 및 키보드 입력과 마찬가지로 마우스 스크롤에 대한 콜백 함수가 있다.

```c++
void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
{
    fov -= (float)yoffset;
    if (fov < 1.0f)
        fov = 1.0f;
    if (fov > 45.0f)
        fov = 45.0f;
}
```

스크롤할 때 `yoffset` 값은 수직으로 스크롤한 양을 알려준다. `scroll_callback` 함수가 호출되면 전역적으로 선언된 `fov` 변수의 내용을 변경한다. 45.0은 기본 `fov` 값이므로 줌 레벨을 1.0과 45.0 사이로 제한하려고 한다.

이제 원근 투영 행렬을 GPU에 매 프레임마다 업로드해야 하지만 이번에는 시야각으로 `fov` 변수를 사용한다.

`부가설명`  
``` 
fov 변수는 사용자의 입력(마우스 스크롤)에 따라 실시간으로 변경될 수 있다.
따라서, 변경된 fov 값을 반영하기 위해서는 매 프레임마다 새로운 투영 행렬을 생성하고, 이 행렬을 GPU에 업로드해야 한다.
투영 행렬은 렌더링 파이프라인의 초반 단계에서 사용되므로, 매 프레임마다 업데이트해야 화면에 정확한 원근감을 표현할 수 있다.  

GPU에 업로드:
projection 변수에 저장된 투영 행렬은 uniform 변수를 통해 쉐이더 프로그램에 전달된다.
쉐이더 프로그램은 이 투영 행렬을 사용하여 물체의 3차원 좌표를 2차원 화면 좌표로 변환한다.

요약:  
glm::perspective 함수는 카메라의 시야각(fov)을 사용하여 원근 투영 행렬을 생성하고, 이 행렬은 매 프레임마다 GPU에 업로드되어 화면에 정확한 원근감을 표현하는 데 사용된다. fov 변수가 변경되면 투영 행렬도 업데이트되어야 하므로, 매 프레임마다 업로드하는 것이 필수적이다.
```

```c++
projection = glm::perspective(glm::radians(fov), 800.0f / 600.0f, 0.1f, 100.0f);
```

마지막으로 스크롤 콜백 함수를 등록하는 것을 잊지 않는다.

```c++
glfwSetScrollCallback(window, scroll_callback);
```

여기 있다. 3D 환경에서 자유로운 움직임을 허용하는 간단한 카메라 시스템을 구현했다.



<video controls src="https://learnopengl.com/video/getting-started/camera_mouse.mp4" title="Title"></video>

## 카메라 클래스

다가오는 장에서는 항상 카메라를 사용하여 장면을 쉽게 둘러보고 모든 각도에서 결과를 볼 수 있다. 그러나 카메라 코드가 각 장에서 상당한 공간을 차지할 수 있으므로 세부 정보를 약간 추상화하고 몇 가지 추가 기능으로 대부분의 작업을 수행하는 자체 `카메라 객체`를 만든다.  
Shader 챕터와 달리 카메라 클래스 생성을 안내하지 않고 내부 작동 방식을 알고 싶다면 (완전히 주석 처리된) 소스 코드를 제공한다.

Shader 객체와 마찬가지로 카메라 클래스를 단일 헤더 파일에 완전히 정의한다. 여기에서 카메라 클래스를 찾을 수 있다. 이 장을 마치면 코드를 이해할 수 있어야 한다. 자신만의 카메라 시스템을 만드는 방법에 대한 예제로 클래스를 한 번 이상 확인하는 것이 좋다.

소개한 카메라 시스템은 대부분의 목적에 적합하고 오일러 각도와 잘 작동하는 카메라이다. 그러나 FPS 카메라 또는 비행 시뮬레이션 카메라와 같은 다른 카메라 시스템을 만들 때 주의해야 한다. 각 카메라 시스템에는 자체 트릭과 특이성이 있으므로 반드시 읽어보아야 한다. 예를 들어, 이 플라이 카메라는 90도 이상이거나 같은 pitch 값을 허용하지 않으며, 롤 값을 고려할 때 (0,1,0)의 정적 위쪽 벡터는 작동하지 않는다.



