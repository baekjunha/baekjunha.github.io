---
categories: graphics
tags: [graphics, opengl, tutorial, setup]
toc: true
toc_sticky: true
author_profile: false
use_math: true 
thumbnail: images/image-2.png
---

## OpenGL 시작하기: 윈도우 생성과 설정 가이드

**자료 출처**: [LearnOpenGL](https://learnopengl.com/)

**1. OpenGL 소개**

*   OpenGL이란 무엇인가?
*   OpenGL 사양 (Specification)
*   OpenGL 구현: 그래픽 카드 제조업체와 드라이버 업데이트의 중요성
*   OpenGL 사양 문서 활용

**2. 중요한 개념: 코어 프로파일 vs. 즉각 모드**

*   이전 방식: 즉각 모드 (Immediate Mode)의 간편함과 비효율성
*   코어 프로파일 (Core-Profile): 현대적인 접근 방식의 유연성과 효율성
*   OpenGL 3.3 코어 프로파일 학습의 중요성

**3. OpenGL 버전과 확장**

*   OpenGL 최신 버전 (OpenGL 4.6 등)
*   과거 버전 (OpenGL 3.3) 학습의 의미
*   OpenGL 확장(Extension) 활용

**4. OpenGL의 핵심 개념**

*   상태 머신 (State Machine): OpenGL 컨텍스트 이해
*   객체 (Object): OpenGL 상태 관리의 추상화

**5. 프로젝트 준비: 윈도우 생성**

*   운영체제 독립적인 OpenGL
*   GLFW 라이브러리 소개 및 선택
*   GLFW 설치 및 빌드 과정
*   CMake 사용 방법
*   Visual Studio 프로젝트 설정 및 빌드
*   라이브러리 연결 방법 (Linking)
    *   IDE 설정 방법
    *   Windows, Linux 환경별 OpenGL 라이브러리 연결
*   GLAD 라이브러리 설정
    *   GLAD 웹 서비스 사용
    *   GLAD 파일 프로젝트에 추가

**6. 헬로 윈도우 (Hello Window)**

*   필수 헤더 파일 포함
*   GLFW 초기화 및 OpenGL 버전 설정
*   윈도우 객체 생성 및 컨텍스트 설정
*   GLAD 초기화
*   뷰포트 (Viewport) 설정 및 콜백 함수
*   렌더링 루프 (Render Loop)
    *   GLFW 윈도우 닫기 처리
    *   입력 이벤트 처리
    *   더블 버퍼링 (Double Buffering)
*   리소스 정리
*   결과 확인: 검은색 윈도우
*   입력 처리: ESC 키로 윈도우 닫기
*   렌더링: 화면 색상 지우기 (glClearColor, glClear)

---
# OpenGL이 무엇인지 간단하게 알아보자

OpenGL은 그래픽과 이미지를 조작하는 데 사용할 수 있는 다양한 함수들을 제공하는 API(Application Programming Interface)라고 할 수 있다. API 자체는 아니고, Khronos 그룹이 개발하고 관리하는 사양(specification)이라고 보는 것이 맞다. 마치 레시피처럼, 각 함수가 어떤 결과를 내야 하고 어떻게 동작해야 하는지 정확히 규정하는 것이다.

이 레시피(사양)만으로는 구체적인 실제 구현 방법은 나와있지 않다. 따라서 각 회사(주로 그래픽 카드 제조업체)는 자신들의 방식대로 이 사양을 구현할 수 있다. 하지만, 사용자에게 보이는 결과는 사양에 맞춰야 하기 때문에, 다른 구현 방식을 사용하더라도 사용자에게는 똑같이 보여야 한다. 예를 들어, 똑같은 `삼각형 그리기` 함수를 사용해도, A사 그래픽 카드와 B사 그래픽 카드에서 구현된 OpenGL 라이브러리가 다르더라도 삼각형이 같은 모양으로 그려져야 한다.

그래픽 카드 제조업체는 OpenGL 라이브러리를 만드는데, 만약 버그가 있으면, 그래픽 카드 드라이버 업데이트를 통해 해결할 수 있다. 드라이버에는 카드가 지원하는 최신 버전의 OpenGL이 포함되어 있기 때문이다. 그래서 그래픽 드라이버를 주기적으로 업데이트하는 것이 중요하다. 마치 자동차에 필요한 부품을 교체하듯이 말이다. 드라이버 업데이트는 시스템의 안정성과 성능 향상에 중요한 역할을 한다.

Khronos 그룹 웹사이트에는 모든 OpenGL 버전의 사양 문서가 공개되어 있다. 특히, 우리가 배울 OpenGL 3.3 버전의 사양은 자세한 내용을 파악하는 데 도움이 되는 좋은 참고 자료가 될 것이다. 사양서는 결과와 동작 방식을 설명하는데, 구현 세부 사항은 없다고 생각하면 된다.

## 중요한 개념: 코어 프로파일 vs. 이전 방식 (즉각 모드)

옛날 OpenGL은 '즉각 모드'(fixed function pipeline)로 사용되어 그래픽 그리기가 쉬웠다. OpenGL 라이브러리 내부에 대부분의 기능이 숨겨져 있었고, 개발자는 OpenGL이 계산하는 방식에 대해 많은 통제권을 갖지 못했다. 마치 컴퓨터가 모든 계산을 해주는 것과 같았다. 시간이 지나면서 개발자들은 더 많은 유연성을 원했고, OpenGL 사양도 더 유연해졌다. 개발자들은 그래픽 처리 과정에 더 많은 제어권을 얻게 된 것이다.

하지만 즉각 모드는 사용하기 쉽지만 매우 비효율적이었다. 그래서 OpenGL 3.2 버전부터 즉각 모드 기능을 단계적으로 없애고, '코어 프로파일' 모드를 사용하도록 장려하기 시작했다. 코어 프로파일은 과거의 기능들을 제거해서 최신 방식을 강요하는 OpenGL 사양의 한 부분이라고 생각하면 된다.

코어 프로파일에서는 낡은 함수를 사용하면 오류가 발생해서 그림을 그릴 수 없다. 즉, 더욱 현대적이고 효율적인 방법을 사용해야만 한다는 의미다. 하지만 이러한 현대적 접근 방식은 배우기가 더 어려울 수도 있다. 즉각 모드는 OpenGL의 내부 동작을 추상화했기 때문에 배우기 쉬웠지만, 실제 동작 원리를 이해하기는 어려웠다. 반면에 코어 프로파일은 OpenGL과 그래픽 프로그래밍에 대한 깊은 이해를 필요로 하지만, 더욱 유연하고 효율적이며 그래픽 프로그래밍에 대한 더 나은 이해를 제공한다.

이 책은 코어 프로파일 OpenGL 3.3 버전을 중심으로 설명한다는 점을 명심해야 한다. 배우기 어렵지만, 노력하면 충분히 가치 있는 학습이 될 것이다.

## 더 높은 버전의 OpenGL

요즘은 OpenGL 4.6 같은 더 높은 버전이 나와 있다. 왜 OpenGL 3.3을 배우는 걸까? OpenGL 3.3부터 나온 새로운 버전들은 OpenGL의 기본 원리를 바꾸지 않고 새로운 기능을 추가했기 때문이다. 새로운 기능은 같은 일을 더 효율적이거나 더 나은 방식으로 처리하는 방법일 뿐이다. 따라서 기본 개념과 기술은 최신 OpenGL 버전에서도 동일하다. 나중에 더 높은 버전의 기능을 사용하려면, 그때 배우면 된다.

## 확장(Extension)

OpenGL은 확장(extension)을 지원하는 훌륭한 기능을 가지고 있다. 그래픽 회사가 새로운 기술이나 최적화 기법을 개발하면, 드라이버에 구현된 확장으로 제공될 수 있다. 만약 응용 프로그램이 실행되는 하드웨어가 해당 확장을 지원한다면, 개발자는 확장으로 제공되는 기능을 이용해서 더욱 고급스럽거나 효율적인 그래픽을 만들 수 있다. 즉, OpenGL이 앞으로 버전 업데이트를 기다릴 필요 없이, 현재 지원하는 기능을 활용할 수 있는 것이다. 확장은 필요에 따라 활용하는 것이지, 무조건 써야 하는 필수적인 요소는 아니다.

## 상태 머신

OpenGL은 하나의 큰 상태 머신(state machine)이라고 볼 수 있다. OpenGL이 현재 어떻게 동작해야 하는지 정의하는 변수들의 모음이다. 이 상태를 OpenGL 컨텍스트(context)라고 부르고, OpenGL을 사용할 때, 옵션을 설정하거나 버퍼를 조작하고, 현재 컨텍스트를 사용하여 렌더링하는 작업을 수행한다.

예를 들어, 선으로 그리기를 원하면, OpenGL의 상태 변수를 변경하여 컨텍스트를 바꿀 수 있다. 이렇게 바뀐 컨텍스트에 따라 다음 명령어는 선으로 그리게 될 것이다. OpenGL은 여러 상태 변경 함수와 상태 사용 함수를 제공하고, 이러한 함수들을 통해 다양한 그래픽 작업을 수행할 수 있다.

## 객체

OpenGL 라이브러리는 C로 작성되었지만, 다른 언어로도 사용 가능하다. C언어의 특성상, 다른 고급 언어로 직접적으로 구현하기 어려운 부분이 있다. 따라서 객체라는 추상화 개념을 도입했다. OpenGL의 객체는 OpenGL 상태의 일부를 나타내는 옵션들의 모음이다. 예를 들어, 그래픽 창의 설정을 나타내는 객체를 만들 수 있고, 크기, 지원 색상 수 등을 설정할 수 있다. 객체는 C 구조체와 비슷하게 생각하면 된다.

객체를 사용할 때는, 먼저 객체를 생성하고, 그 참조 ID를 저장한다. 그리고 컨텍스트의 특정 위치에 객체를 바인딩(binding) 한다. 그 후 객체의 옵션을 설정하고, 다시 기본값으로 바인딩을 해제하는 작업을 반복한다. 이렇게 하면, 여러 객체를 만들어서 각 객체의 설정을 따로 관리할 수 있고, 특정 객체를 활용하여 그림을 그릴 수 있다.

## 시작하기

이제 OpenGL이 무엇인지, 어떻게 동작하는지, 그리고 객체 사용법에 대해 조금 배웠다. 이 책에서는 각 단계를 자세하게 설명하고, 충분한 예제를 통해 OpenGL을 잘 이해할 수 있도록 도와줄 것이다.

## 윈도우 만들기

멋진 그래픽을 만들기 전에 가장 먼저 해야 할 일은 OpenGL 컨텍스트를 만들고 그림을 그릴 애플리케이션 윈도우를 만드는 것이다. 하지만 이러한 작업들은 운영체제마다 다르며, OpenGL은 의도적으로 이러한 작업들로부터 자신을 추상화하려고 한다. 즉, 윈도우를 만들고, 컨텍스트를 정의하고, 사용자 입력을 직접 처리해야 한다.

다행히도 이러한 기능을 제공하는 라이브러리가 많이 있으며, 일부는 OpenGL에 특화되어 있다. 이러한 라이브러리는 운영체제에 따라 달라지는 작업을 모두 처리해주고, 렌더링할 수 있는 윈도우와 OpenGL 컨텍스트를 제공한다. 인기 있는 라이브러리로는 GLUT, SDL, SFML 및 GLFW가 있다. LearnOpenGL에서는 GLFW를 사용할 것이다. 다른 라이브러리를 사용해도 괜찮다. 대부분의 설정이 GLFW와 유사할 것이다.

### GLFW

GLFW는 C로 작성된 라이브러리이며, OpenGL을 위해 특별히 만들어졌다. GLFW는 화면에 멋진 그래픽을 렌더링하는 데 필요한 최소한의 기능들을 제공한다. OpenGL 컨텍스트를 만들고, 윈도우 매개변수를 정의하고, 사용자 입력을 처리할 수 있다.

이번 장과 다음 장에서는 GLFW를 설치하고 실행하여 OpenGL 컨텍스트를 제대로 만들고, 간단한 윈도우를 표시하여 시험해 보는 데 집중할 것이다. 이 장에서는 GLFW 라이브러리를 가져오고, 빌드하고, 연결하는 단계를 자세히 설명한다. 이 글을 쓰는 시점에는 Microsoft Visual Studio 2019 IDE를 사용한다 (최신 버전의 Visual Studio에서도 프로세스는 동일하다). Visual Studio (또는 이전 버전)를 사용하지 않더라도 걱정하지 마라. 대부분의 다른 IDE에서도 프로세스는 비슷할 것이다.

### GLFW 빌드

GLFW는 웹페이지의 [다운로드 페이지](https://www.glfw.org/download.html)에서 얻을 수 있다. GLFW는 Visual Studio 2012부터 2019까지 사전 컴파일된 바이너리와 헤더 파일을 이미 가지고 있지만, 완전성을 위해 소스 코드에서 GLFW를 직접 컴파일할 것이다. 이는 모든 라이브러리가 사전 컴파일된 바이너리를 제공하는 것은 아니기 때문에 오픈 소스 라이브러리를 직접 컴파일하는 과정을 경험해보기 위함이다. 따라서 Source 패키지를 다운로드하라.

모든 라이브러리를 64비트 바이너리로 빌드할 것이므로, 사전 컴파일된 바이너리를 사용하는 경우 64비트 바이너리를 다운로드하라.
소스 패키지를 다운로드했으면 압축을 풀고 내용을 열어라. 다음 몇 가지 항목에만 관심이 있다.

*   컴파일로 생성된 라이브러리.
*   include 폴더.

소스 코드에서 라이브러리를 컴파일하면 결과 라이브러리가 CPU/OS에 완벽하게 맞춰진다. 사전 컴파일된 바이너리는 항상 제공하지 않는 장점이다 (사전 컴파일된 바이너리가 시스템에서 사용할 수 없는 경우도 있다). 그러나 소스 코드를 오픈 소스로 제공하면 모든 사람이 애플리케이션 개발에 동일한 IDE 또는 빌드 시스템을 사용하는 것은 아니기 때문에 제공된 프로젝트/솔루션 파일이 다른 사람의 설정과 호환되지 않을 수 있다. 따라서 사람들은 제공된 .c/.cpp 및 .h/.hpp 파일로 자신의 프로젝트/솔루션을 설정해야 하며, 이는 번거롭다. 바로 이러한 이유 때문에 CMake라는 도구가 있다.

### CMake

CMake는 미리 정의된 CMake 스크립트를 사용하여 소스 코드 파일 모음에서 사용자가 선택한 프로젝트/솔루션 파일 (예: Visual Studio, Code::Blocks, Eclipse)을 생성할 수 있는 도구다. 이를 통해 GLFW의 소스 패키지에서 Visual Studio 2019 프로젝트 파일을 생성하여 라이브러리를 컴파일할 수 있다. 먼저 [다운로드 페이지](https://cmake.org/download/)에서 CMake를 다운로드하여 설치해야 한다.

CMake가 설치되면 명령줄 또는 GUI를 통해 CMake를 실행하도록 선택할 수 있다. 복잡하게 만들고 싶지 않으므로 GUI를 사용하겠다. CMake는 소스 코드 폴더와 바이너리용 대상 폴더가 필요하다. 소스 코드 폴더로는 다운로드한 GLFW 소스 패키지의 루트 폴더를 선택하고, 빌드 폴더로는 새 디렉토리인 build를 만들고 해당 디렉토리를 선택한다.

소스 및 대상 폴더가 설정되면 Configure 버튼을 클릭하여 CMake가 필요한 설정과 소스 코드를 읽을 수 있도록 한다. 그런 다음 프로젝트에 대한 생성기를 선택해야 하며, Visual Studio 2019를 사용하고 있으므로 Visual Studio 16 옵션을 선택한다 (Visual Studio 2019는 Visual Studio 16이라고도 함). 그러면 CMake가 결과 라이브러리를 구성하기 위한 가능한 빌드 옵션을 표시한다. 기본값으로 두고 Configure를 다시 클릭하여 설정을 저장한다. 설정이 완료되면 Generate를 클릭하면 결과 프로젝트 파일이 빌드 폴더에 생성된다.

### 컴파일

빌드 폴더에서 GLFW.sln이라는 파일을 찾을 수 있으며 Visual Studio 2019로 연다. CMake가 적절한 구성 설정이 이미 포함된 프로젝트 파일을 생성했으므로 솔루션만 빌드하면 된다. CMake는 솔루션을 자동으로 구성하여 64비트 라이브러리로 컴파일해야 한다. 이제 빌드 솔루션을 누른다. 그러면 빌드/src/Debug에서 glfw3.lib라는 컴파일된 라이브러리 파일을 얻을 수 있다.

라이브러리를 생성했으면 IDE가 OpenGL 프로그램의 라이브러리와 include 파일을 찾을 위치를 알아야 한다. 이를 수행하는 데는 두 가지 일반적인 접근 방식이 있다.

IDE/컴파일러의 /lib 및 /include 폴더를 찾고 GLFW의 include 폴더 내용을 IDE의 /include 폴더에 추가하고 마찬가지로 glfw3.lib를 IDE의 /lib 폴더에 추가한다. 이것은 작동하지만 권장되는 방법은 아니다. 라이브러리 및 include 파일을 추적하기 어렵고 IDE/컴파일러를 새로 설치하면 이 프로세스를 다시 수행해야 한다.
또 다른 접근 방식 (권장)은 타사 라이브러리의 모든 헤더 파일/라이브러리가 포함된 원하는 위치에 새 디렉토리 세트를 만들어 IDE/컴파일러에서 참조할 수 있도록 하는 것이다. 예를 들어 OpenGL 프로젝트에 대한 모든 라이브러리 및 헤더 파일을 각각 저장하는 Libs 및 Include 폴더가 포함된 단일 폴더를 만들 수 있다. 이제 모든 타사 라이브러리가 단일 위치 내에 정리된다 (여러 컴퓨터에서 공유할 수 있음). 그러나 새 프로젝트를 만들 때마다 IDE에게 해당 디렉토리를 찾을 위치를 알려야 한다.
필요한 파일을 원하는 위치에 저장했으면 첫 번째 OpenGL GLFW 프로젝트를 만들 수 있다.

### 첫 번째 프로젝트

먼저 Visual Studio를 열고 새 프로젝트를 만든다. 여러 옵션이 제공되는 경우 C++를 선택하고 빈 프로젝트를 선택한다 (프로젝트 이름을 적절하게 지정하는 것을 잊지 마라). 모든 작업을 64비트로 수행하고 프로젝트가 기본적으로 32비트로 설정되므로 디버그 옆에 있는 드롭다운을 상단에서 x86에서 x64로 변경해야 한다.

완료되면 이제 첫 번째 OpenGL 애플리케이션을 만들 수 있는 작업 공간이 있다!

### 연결

프로젝트에서 GLFW를 사용하려면 라이브러리를 프로젝트와 연결해야 한다. 링커 설정에서 glfw3.lib를 사용하고 싶다고 지정하여 수행할 수 있지만 프로젝트는 타사 라이브러리를 다른 디렉토리에 저장하므로 glfw3.lib를 찾을 위치를 아직 알지 못한다. 따라서 먼저 이 디렉토리를 프로젝트에 추가해야 한다.

IDE에게 라이브러리 및 include 파일을 찾아야 할 때 이 디렉토리를 고려하도록 지시할 수 있다. 솔루션 탐색기에서 프로젝트 이름을 마우스 오른쪽 버튼으로 클릭한 다음 아래 이미지와 같이 VC++ 디렉토리로 이동한다.

거기에서 자체 디렉토리를 추가하여 프로젝트가 검색할 위치를 알 수 있다. 텍스트에 수동으로 삽입하거나 적절한 위치 문자열을 클릭하고 <편집..> 옵션을 선택하여 수행할 수 있다. 라이브러리 디렉토리와 Include 디렉토리 모두에 대해 이 작업을 수행한다.

여기에서 원하는 만큼의 추가 디렉토리를 추가할 수 있으며 해당 시점부터 IDE는 라이브러리 및 헤더 파일을 검색할 때 해당 디렉토리를 검색한다. GLFW의 Include 폴더가 포함되면 <GLFW/..>를 포함하여 GLFW의 모든 헤더 파일을 찾을 수 있다. 라이브러리 디렉토리에도 동일하게 적용된다.

VS가 필요한 모든 파일을 찾을 수 있으므로 링커 탭과 입력을 통해 GLFW를 프로젝트에 연결할 수 있다.

그런 다음 라이브러리에 연결하려면 라이브러리 이름을 링커에 지정해야 한다. 라이브러리 이름이 glfw3.lib이므로 추가 종속성 필드에 추가한다 (수동으로 또는 <편집..> 옵션을 사용하여). 해당 시점부터 컴파일할 때 GLFW가 연결된다. GLFW 외에도 OpenGL 라이브러리에 대한 링크 항목도 추가해야 하지만 운영체제에 따라 다를 수 있다.

### Windows의 OpenGL 라이브러리

Windows를 사용하는 경우 OpenGL 라이브러리 opengl32.lib는 Visual Studio를 설치할 때 기본적으로 설치되는 Microsoft SDK와 함께 제공된다. 이 장에서는 VS 컴파일러를 사용하고 Windows에 있으므로 opengl32.lib를 링커 설정에 추가한다. OpenGL 라이브러리의 64비트 버전은 32비트 버전과 마찬가지로 opengl32.lib라고 한다.

### Linux의 OpenGL 라이브러리

Linux 시스템에서는 링커 설정에 -lGL을 추가하여 libGL.so 라이브러리에 연결해야 한다. 라이브러리를 찾을 수 없으면 Mesa, NVidia 또는 AMD 개발 패키지를 설치해야 할 수 있다.

그런 다음 GLFW 및 OpenGL 라이브러리를 모두 링커 설정에 추가했으면 다음과 같이 GLFW에 대한 헤더 파일을 포함할 수 있다.

```cpp
#include <GLFW/glfw3.h>
```
GCC로 컴파일하는 Linux 사용자의 경우 다음 명령줄 옵션이 프로젝트 컴파일에 도움이 될 수 있다. -lglfw3 -lGL -lX11 -lpthread -lXrandr -lXi -ldl. 해당 라이브러리를 올바르게 연결하지 못하면 많은 정의되지 않은 참조 오류가 발생한다.
이것으로 GLFW의 설정 및 구성이 완료된다.

### GLAD

아직 완전히 끝나지 않았다. 아직 해야 할 일이 하나 더 있다. OpenGL은 실제로 표준/사양일 뿐이므로 특정 그래픽 카드가 지원하는 드라이버에 사양을 구현하는 것은 드라이버 제조업체에 달려 있기 때문이다. OpenGL 드라이버에는 여러 가지 버전이 있으므로 대부분의 함수의 위치는 컴파일 시간에 알 수 없으며 런타임에 쿼리해야 한다. 그런 다음 개발자는 필요한 함수의 위치를 검색하고 나중에 사용하기 위해 함수 포인터에 저장해야 한다. 해당 위치를 검색하는 것은 OS에 따라 다르다. Windows에서는 다음과 같다.

```c++
// 함수의 프로토타입 정의
typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);
// 함수를 찾아 함수 포인터에 할당
GL_GENBUFFERS glGenBuffers  = (GL_GENBUFFERS)wglGetProcAddress("glGenBuffers");
// 이제 함수를 정상적으로 호출할 수 있음
unsigned int buffer;
glGenBuffers(1, &buffer);
```

보시다시피 코드는 복잡해 보이고 아직 선언되지 않은 모든 필요한 함수에 대해 이 작업을 수행하는 것은 번거로운 프로세스이다. 고맙게도 이를 위한 라이브러리도 있으며 GLAD가 인기 있고 최신 라이브러리이다.

### GLAD 설정

GLAD는 우리가 이야기한 모든 번거로운 작업을 관리하는 오픈 소스 라이브러리이다. GLAD는 대부분의 일반적인 오픈 소스 라이브러리와 약간 다른 구성 설정을 가지고 있다. GLAD는 웹 서비스를 사용한다. 여기서 GLAD에 정의하고 싶고 해당 버전에 따라 모든 관련 OpenGL 함수를 로드하고 싶은 OpenGL 버전을 알려줄 수 있다.

GLAD 웹 서비스로 이동하여 언어가 C++로 설정되어 있는지 확인하고 API 섹션에서 OpenGL 버전 3.3 이상을 선택한다 (사용할 것이다. 더 높은 버전도 괜찮다). 또한 프로필이 Core로 설정되어 있고 로더 생성 옵션이 선택되어 있는지 확인한다. 확장을 무시하고 (지금은) 생성을 클릭하여 결과 라이브러리 파일을 생성한다.

GLAD1 버전을 사용하십시오. GLAD2 버전도 있지만 여기서는 컴파일되지 않는다.
GLAD는 이제 두 개의 include 폴더와 단일 glad.c 파일이 포함된 zip 파일을 제공해야 한다. 두 include 폴더 (glad 및 KHR)를 include 디렉토리에 복사하거나 (또는 이러한 폴더를 가리키는 추가 항목을 추가) glad.c 파일을 프로젝트에 추가한다.

이전 단계를 수행한 후 파일 위에 다음 include 지시문을 추가할 수 있어야 한다.

```c++
#include <glad/glad.h>
```



### 추가 자료

*   [GLFW: Window Guide](http://www.glfw.org/docs/latest/window_guide.html): GLFW 윈도우를 설정하고 구성하는 방법에 대한 공식 GLFW 가이드입니다.
*   [Building applications](http://cs.lmu.edu/~ray/notes/openglexamples/): 애플리케이션의 컴파일/연결 프로세스와 발생할 수 있는 가능한 오류 (및 해결 방법) 목록을 제공합니다.
*   [GLFW with Code::Blocks](https://www.youtube.com/watch?v=mGjTq2S6H30): Code::Blocks IDE에서 GLFW를 빌드합니다.
*   [Running CMake](https://www.wikihow.com/Run-CMake): Windows 및 Linux에서 CMake를 실행하는 방법에 대한 간략한 개요입니다.
*   [Writing a build system under Linux](http://dereuromark.de/2012/12/10/writing-a-build-system-under-linux/): Linux에서 빌드 시스템을 작성하는 방법에 대한 Wouter Verholst의 autotools 튜토리얼입니다.
*   [Polytonic/Glitter](https://github.com/Polytonic/Glitter): 관련 라이브러리가 모두 미리 구성된 간단한 상용구 프로젝트입니다. 직접 모든 라이브러리를 컴파일해야 하는 번거로움 없이 샘플 프로젝트를 원하는 경우에 유용합니다.


## 헬로 윈도우

GLFW가 제대로 작동하는지 확인해본다. 먼저 .cpp 파일을 만들고 새로 만든 파일 맨 위에 다음 include를 추가한다.

```c++
#include <glad/glad.h>
#include <GLFW/glfw3.h>
```

GLFW보다 먼저 GLAD를 포함해야 한다. GLAD에 대한 include 파일에는 백그라운드에서 필요한 OpenGL 헤더(예: GL/gl.h)가 포함되어 있어서 OpenGL이 필요한 다른 헤더 파일(예: GLFW)보다 먼저 GLAD를 포함해야 한다.

다음으로, GLFW 윈도우를 인스턴스화할 main 함수를 만든다.

```c++
int main()
{
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
  
    return 0;
}
```

main 함수에서 먼저 `glfwInit()`으로 GLFW를 초기화한 다음 `glfwWindowHint()`를 사용해서 GLFW를 구성할 수 있다. `glfwWindowHint()`의 첫 번째 인수는 구성하려는 옵션을 나타내는데, `GLFW_` 접두사가 붙은 가능한 옵션의 큰 enum에서 옵션을 선택할 수 있다. 두 번째 인수는 옵션의 값을 설정하는 정수이다. 가능한 모든 옵션과 해당 값 목록은 GLFW의 [윈도우 처리 문서](http://www.glfw.org/docs/latest/window_guide.html#window_hints)에서 찾을 수 있다. 지금 애플리케이션을 실행하려고 시도할 때 정의되지 않은 참조 오류가 많이 발생하면 GLFW 라이브러리를 성공적으로 연결하지 못했다는 의미이다.

이 책의 초점은 OpenGL 버전 3.3이므로, 사용하려는 OpenGL 버전이 3.3이라고 GLFW에 알려주고 싶다. 이렇게 하면 GLFW는 OpenGL 컨텍스트를 만들 때 적절한 준비를 할 수 있다. 이렇게 하면 사용자가 적절한 OpenGL 버전을 가지고 있지 않은 경우 GLFW가 실행되지 않는다. 주 버전과 부 버전을 모두 3으로 설정한다. 또한 코어 프로필을 명시적으로 사용하고 싶다고 GLFW에 알린다. 코어 프로필을 사용하고 싶다고 GLFW에 알리면 더 이상 필요하지 않은 이전 버전과 호환되는 기능 없이 더 작은 OpenGL 기능 하위 집합에 액세스할 수 있다. Mac OS X에서는 작동하려면 초기화 코드에 `glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);`를 추가해야 한다.

시스템/하드웨어에 OpenGL 버전 3.3 이상이 설치되어 있는지 확인한다. 그렇지 않으면 애플리케이션이 충돌하거나 정의되지 않은 동작을 표시한다. 컴퓨터에서 OpenGL 버전을 찾으려면 Linux 컴퓨터에서 `glxinfo`를 호출하거나 Windows용 [OpenGL Extension Viewer](http://realtech-vr.com/home/glview)와 같은 유틸리티를 사용한다. 지원되는 버전이 낮으면 비디오 카드가 OpenGL 3.3+를 지원하는지 확인하거나 (그렇지 않으면 정말 오래된 것이다) 드라이버를 업데이트한다.
다음으로 윈도우 객체를 만들어야 한다. 이 윈도우 객체는 모든 윈도우 데이터를 보유하고 있으며 대부분의 다른 GLFW 함수에 필요하다.

```c++
GLFWwindow* window = glfwCreateWindow(800, 600, "LearnOpenGL", NULL, NULL);
if (window == NULL)
{
    std::cout << "Failed to create GLFW window" << std::endl;
    glfwTerminate();
    return -1;
}
glfwMakeContextCurrent(window);
```

`glfwCreateWindow` 함수는 첫 번째 두 인수로 윈도우 너비와 높이가 필요하다. 세 번째 인수를 사용하면 윈도우 이름을 만들 수 있다. 지금은 "LearnOpenGL"이라고 부르지만 원하는 대로 이름을 지정할 수 있다. 마지막 두 매개변수는 무시할 수 있다. 이 함수는 나중에 다른 GLFW 작업에 필요한 `GLFWwindow` 객체를 반환한다. 그 후 GLFW에게 윈도우 컨텍스트를 현재 스레드의 기본 컨텍스트로 만들도록 지시한다.

### GLAD

이전 장에서 GLAD가 OpenGL에 대한 함수 포인터를 관리한다고 언급했으므로 OpenGL 함수를 호출하기 전에 GLAD를 초기화하려고 한다.

```c++
if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
{
    std::cout << "Failed to initialize GLAD" << std::endl;
    return -1;
}
```

GLAD에게 OpenGL 함수 포인터의 주소를 로드하는 함수를 전달한다. 이 함수는 OS에 따라 다르다. GLFW는 컴파일 중인 OS를 기반으로 올바른 함수를 정의하는 `glfwGetProcAddress`를 제공한다.

### 뷰포트

렌더링을 시작하기 전에 마지막으로 해야 할 일이 하나 있다. OpenGL에게 렌더링 윈도우의 크기를 알려주어야 한다. 그러면 OpenGL은 윈도우를 기준으로 데이터를 표시하고 좌표를 처리하는 방법을 알 수 있다. `glViewport` 함수를 통해 이러한 크기를 설정할 수 있다.

```c++
glViewport(0, 0, 800, 600);
```

`glViewport`의 처음 두 매개변수는 윈도우의 왼쪽 하단 모서리의 위치를 설정한다. 세 번째와 네 번째 매개변수는 픽셀 단위로 렌더링 윈도우의 너비와 높이를 설정한다. GLFW의 윈도우 크기와 동일하게 설정한다.

GLFW의 크기보다 작은 값으로 뷰포트 크기를 실제로 설정할 수 있다. 그러면 모든 OpenGL 렌더링이 더 작은 윈도우에 표시되고 예를 들어 OpenGL 뷰포트 외부에 다른 요소를 표시할 수 있다.

백그라운드에서 OpenGL은 `glViewport`를 통해 지정된 데이터를 사용하여 처리한 2D 좌표를 화면의 좌표로 변환한다. 예를 들어 위치 (-0.5,0.5)의 처리된 점은 (최종 변환으로) 화면 좌표에서 (200,450)으로 매핑된다. OpenGL에서 처리된 좌표는 -1과 1 사이이므로 범위 (-1에서 1)를 (0, 800)과 (0, 600)으로 효과적으로 매핑한다.
그러나 사용자가 윈도우 크기를 조정하는 순간 뷰포트도 조정해야 한다. 윈도우 크기가 조정될 때마다 호출되는 콜백 함수를 윈도우에 등록할 수 있다. 이 크기 조정 콜백 함수에는 다음과 같은 프로토타입이 있다.

```c++
void framebuffer_size_callback(GLFWwindow* window, int width, int height);
```

프레임 버퍼 크기 함수는 `GLFWwindow`를 첫 번째 인수로 사용하고 새 윈도우 크기를 나타내는 두 개의 정수를 사용한다. 윈도우 크기가 변경될 때마다 GLFW는 이 함수를 호출하고 처리할 수 있도록 적절한 인수를 채운다.

```c++
void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
    glViewport(0, 0, width, height);
}
```

`glfwSetFramebufferSizeCallback`을 등록하여 모든 윈도우 크기 조정에서 이 함수를 호출하고 싶다는 것을 GLFW에 알려야 한다.

```c++
glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
```

윈도우가 처음 표시되면 결과 윈도우 크기로 `framebuffer_size_callback`도 호출된다. 망막 디스플레이의 경우 너비와 높이가 원래 입력 값보다 훨씬 높아진다.

자체 함수를 등록하기 위해 설정할 수 있는 콜백 함수가 많이 있다. 예를 들어 조이스틱 입력 변경을 처리하고, 오류 메시지를 처리하는 콜백 함수를 만들 수 있다. 윈도우를 만든 후 렌더링 루프가 시작되기 전에 콜백 함수를 등록한다.

### 엔진 준비

애플리케이션이 단일 이미지를 그리고 즉시 종료하여 윈도우를 닫는 것을 원하지 않는다. 프로그램이 명시적으로 중지하라는 지시를 받을 때까지 애플리케이션이 이미지를 계속 그리고 사용자 입력을 처리하기를 원한다. 이러한 이유로 GLFW에게 중지하라는 지시를 받을 때까지 계속 실행되는 while 루프 (이제 렌더링 루프라고 함)를 만들어야 한다. 다음 코드는 매우 간단한 렌더링 루프를 보여준다.

```c++
while(!glfwWindowShouldClose(window))
{
    glfwSwapBuffers(window);
    glfwPollEvents();    
}
```

`glfwWindowShouldClose` 함수는 각 루프 반복의 시작 부분에서 GLFW가 닫히도록 지시되었는지 확인한다. 그렇다면 이 함수는 true를 반환하고 렌더링 루프가 중지된 후 애플리케이션을 닫을 수 있다.
`glfwPollEvents` 함수는 이벤트 (예: 키보드 입력 또는 마우스 움직임 이벤트)가 트리거되었는지 확인하고, 윈도우 상태를 업데이트하고, 해당 함수 (콜백 메서드를 통해 등록할 수 있음)를 호출한다. `glfwSwapBuffers`는 이 렌더링 반복 중에 렌더링하는 데 사용되는 색상 버퍼 (GLFW 윈도우의 각 픽셀에 대한 색상 값이 포함된 큰 2D 버퍼)를 바꾸고 화면에 출력으로 표시한다.

### 더블 버퍼

애플리케이션이 단일 버퍼에 그리면 결과 이미지에 깜박임 문제가 표시될 수 있다. 이는 결과 출력 이미지가 즉시 그려지지 않고 픽셀 단위로 일반적으로 왼쪽에서 오른쪽으로 그리고 위에서 아래로 그려지기 때문이다. 이 이미지는 렌더링되는 동안 사용자에게 즉시 표시되지 않으므로 결과에 아티팩트가 포함될 수 있다. 이러한 문제를 해결하기 위해 윈도우 애플리케이션은 렌더링에 더블 버퍼를 적용한다. 프런트 버퍼에는 화면에 표시되는 최종 출력 이미지가 포함되어 있고 모든 렌더링 명령은 백 버퍼에 그려진다. 모든 렌더링 명령이 완료되는 즉시 백 버퍼를 프런트 버퍼로 바꾸어 이미지를 렌더링하지 않고도 표시할 수 있으므로 위에서 언급한 모든 아티팩트를 제거한다.

### 마지막으로 할 일

렌더링 루프에서 나가자마자 할당된 모든 GLFW 리소스를 적절하게 정리/삭제하고 싶다. main 함수의 끝에서 호출하는 `glfwTerminate` 함수를 통해 이 작업을 수행할 수 있다.

```c++
glfwTerminate();
return 0;
```

이렇게 하면 모든 리소스를 정리하고 애플리케이션을 제대로 종료한다. 이제 애플리케이션을 컴파일해 보십시오. 모든 것이 잘 되면 다음과 같은 출력이 표시된다.

매우 지루하고 지루한 검은색 이미지라면 제대로 한 것이다! 올바른 이미지를 얻지 못했거나 모든 것이 어떻게 맞춰지는지 혼란스럽다면 [여기](https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/1.2.hello_window/hello_window.cpp)에서 전체 소스 코드를 확인하십시오 (다른 색상으로 깜박이기 시작했다면 계속 읽으십시오).

애플리케이션 컴파일에 문제가 있는 경우 먼저 모든 링커 옵션이 올바르게 설정되었는지, IDE에 올바른 디렉토리를 제대로 포함했는지 확인하십시오 (이전 장에서 설명한 대로). 또한 코드가 올바른지 확인하십시오. 전체 소스 코드와 비교하여 확인할 수 있다.

### 입력

또한 GLFW에서 일부 형태의 입력 제어를 하고 싶고 GLFW의 여러 입력 함수를 통해 이를 달성할 수 있다. GLFW의 `glfwGetKey` 함수를 사용할 것이다. 이 함수는 윈도우를 입력으로 키와 함께 사용한다. 이 함수는 이 키가 현재 눌려지고 있는지 여부를 반환한다. 모든 입력 코드를 체계적으로 유지하기 위해 `processInput` 함수를 만든다.

```c++
void processInput(GLFWwindow *window)
{
    if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);
}
```

여기서 사용자가 escape 키를 눌렀는지 확인한다 (누르지 않은 경우 `glfwGetKey`는 `GLFW_RELEASE`를 반환한다). 사용자가 escape 키를 누른 경우 `glfwSetWindowShouldClose`를 사용하여 `WindowShouldClose` 속성을 true로 설정하여 GLFW를 닫는다. 그런 다음 메인 while 루프의 다음 조건 확인이 실패하고 애플리케이션이 닫힌다.

그런 다음 렌더링 루프의 모든 반복에서 `processInput`을 호출한다.

```c++
while (!glfwWindowShouldClose(window))
{
    processInput(window);

    glfwSwapBuffers(window);
    glfwPollEvents();
}
```

이렇게 하면 특정 키 누름을 쉽게 확인하고 각 프레임에 따라 적절하게 대응할 수 있다. 렌더링 루프의 반복을 더 일반적으로 프레임이라고 한다.

### 렌더링

렌더링 루프의 모든 반복 또는 프레임에서 모든 렌더링 명령을 실행하고 싶기 때문에 모든 렌더링 명령을 렌더링 루프에 넣고 싶다. 다음과 같이 보일 것이다.

```c++
// 렌더링 루프
while(!glfwWindowShouldClose(window))
{
    // 입력
    processInput(window);

    // 여기에 렌더링 명령
    ...

    // 이벤트 확인 및 호출하고 버퍼를 바꿈
    glfwPollEvents();
    glfwSwapBuffers(window);
}
```

실제로 작동하는지 테스트하기 위해 원하는 색상으로 화면을 지우고 싶다. 프레임 시작 시 화면을 지우고 싶다. 그렇지 않으면 이전 프레임의 결과가 계속 표시된다 (찾고 있는 효과일 수 있지만 일반적으로는 그렇지 않다). `glClear`를 사용하여 화면의 색상 버퍼를 지울 수 있다. 여기서 지우려는 버퍼를 지정하기 위해 버퍼 비트를 전달한다. 설정할 수 있는 가능한 비트는 `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT` 및 `GL_STENCIL_BUFFER_BIT`이다. 지금은 색상 값만 신경 쓰므로 색상 버퍼만 지운다.

```c++
glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
glClear(GL_COLOR_BUFFER_BIT);
```

또한 `glClearColor`를 사용하여 화면을 지울 색상을 지정한다. `glClear`를 호출하고 색상 버퍼를 지울 때마다 전체 색상 버퍼가 `glClearColor`로 구성된 색상으로 채워진다. 이렇게 하면 어두운 녹색-파란색 색상이 된다.

OpenGL 장에서 기억할 수 있듯이 `glClearColor` 함수는 상태 설정 함수이고 `glClear`는 현재 상태를 사용하여 지우는 색상을 검색한다는 점에서 상태 사용 함수이다.

애플리케이션의 전체 소스 코드는 [여기](https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/1.2.hello_window_clear/hello_window_clear.cpp)에서 찾을 수 있다.
