---
published: true
title: "캡스톤 디자인 프로젝트: AI 캐릭터 구현 기술 로드맵"
categories: capstone
tags: [capstone, ai, unity, guide] # 태그는 여러 개를 목록 형태로 관리하는 것이 좋습니다.
date: 2025-09-29 17:09:01 +0900 # 글 작성 날짜와 시간을 꼭 넣어주세요.
toc: true
toc_sticky: true
author_profile: false
use_math: true 
thumbnail: images/GLM2.jpg
---

### 캡스톤 디자인 프로젝트: AI 캐릭터 구현 기술 로드맵

우리 팀의 캡스톤 디자인 프로젝트, '살아있는' AI 캐릭터 플랫폼 구축을 위한 핵심 기술 로드맵을 공유합니다. 이 문서는 우리가 한 학기 동안 학습하고 구현해야 할 기술 스택과 각 기술의 중요성을 명확히 제시하여, 모두가 프로젝트의 큰 그림을 이해하고 효과적으로 협력할 수 있도록 돕기 위해 작성되었습니다.

-----

1.  AI 코어 아키텍처: 캐릭터의 지능과 기억
2.  클라이언트 구현: 성능, 안정성, 비용 관리
3.  게임플레이 시스템: 데이터 관리와 상호작용
4.  UX 및 라이브 운영: 몰입감과 지속 가능한 성장
5.  프로젝트 기술 스택 학습 가이드

-----

### 1\. AI 코어 아키텍처: 캐릭터의 지능과 기억

이 파트는 AI 캐릭터가 지능적으로 사고하고, 일관된 정체성을 유지하며, 플레이어와의 관계를 기억하게 만드는 핵심 기술을 다룹니다.

  * **LLM (Gemini) API 통신**: 플레이어의 입력을 AI 서버로 전송하고 응답을 받아오는 핵심 통신 채널입니다. 게임 내 실시간 대화 생성을 담당합니다.

  * **RAG (검색 증강 생성) 시스템**: LLM의 기억력 한계를 보완하는 기술입니다. 캐릭터의 고유한 성격, 배경 이야기, 플레이어와의 주요 사건 등 **장기 기억**을 데이터베이스에 저장합니다. 이후 대화의 맥락에 맞는 정보를 실시간으로 검색하여 LLM에게 제공함으로써, 캐릭터가 일관된 정체성을 유지하며 답변하도록 돕습니다.

      * 특히 우리 프로젝트는 **하이브리드 검색(Hybrid Search)** 방식을 사용합니다. 이는 단순히 사용자의 질문과 의미적으로 유사한 기억을 찾는 것을 넘어, **'호감도'나 '관계 상태' 같은 현재 게임 데이터와 연결된 정보(메타데이터)를 먼저 필터링**하는 기술입니다. 이 덕분에 AI는 '어제 다퉜던 상황'을 인지하고 그에 맞는 미묘한 감정적 답변을 생성할 수 있습니다.

  * **프롬프트 엔지니어링**: AI에게 캐릭터의 정체성, 말투, 행동 규칙을 명시적으로 지시하는 과정입니다. 체계적인 프롬프트 설계는 캐릭터의 일관성을 유지할 뿐만 아니라, 불필요한 토큰 사용을 줄여 **API 호출 비용을 직접적으로 절감**하는 효과도 있습니다.

-----

### 2\. 클라이언트 구현: 성능, 안정성, 비용 관리

이 파트는 AI 모델과의 통신을 안정적으로 처리하고, 사용자에게 쾌적한 경험을 제공하며, 장기적인 운영 비용을 관리하는 기술들을 다룹니다.

  * **UniTask 기반 비동기 처리**: LLM API의 응답을 기다리는 동안 게임이 멈추는 현상(프레임 드랍)을 방지하는 핵심 기술입니다. 모든 네트워크 통신을 메인 스레드와 분리된 비동기 방식으로 처리하여 **끊김 없는 사용자 경험을 제공**합니다.

  * **네트워크 복원력 설계**: API 응답이 지연될 경우를 대비한 **타임아웃(Timeout)** 처리와, 일시적인 통신 오류 발생 시 서버에 부담을 주지 않으면서 **안정적으로 재시도**하는 스마트 재시도 로직을 구현합니다.

  * **의존성 주입 (VContainer)**: API 통신, 데이터 관리, UI 등 각 기능 모듈을 독립적으로 설계하는 아키텍처 패턴입니다. 기능 간의 의존도를 낮춰 코드의 **유지보수성과 확장성을 높이고, 팀원 간의 협업 효율을 극대화**합니다.

  * **지능형 응답 캐싱**: "이름이 뭐야?"처럼 상황과 관계없이 답변이 항상 동일한 정적인 정보는 그 응답을 캐시에 저장합니다. 불필요한 API 호출을 줄여 **비용을 절감하고 응답 속도를 향상**시킵니다.

  * **모델 티어링**: 간단한 일상 대화에는 저렴한 소형 AI 모델을, 관계의 분기점이 되는 중요 대화에는 고성능 모델을 사용하는 등 **상황의 중요도에 따라 다른 모델을 전략적으로 할당**하여 비용 효율성을 최적화합니다.

-----

### 3\. 게임플레이 시스템: 데이터 관리와 상호작용

이 파트는 플레이어의 행동이 AI 캐릭터와의 관계에 실질적인 영향을 미치도록 만드는 게임 로직과 데이터 관리 기술을 다룹니다.

  * **ScriptableObject 기반 데이터 설계**: **호감도, 신뢰도** 같은 캐릭터의 관계 데이터를 코드와 분리된 에셋 파일로 관리합니다. 이를 통해 기획자나 디자이너가 코드를 직접 수정하지 않고도 **게임 밸런스를 쉽게 조절**할 수 있습니다.

  * **관계 발전 시스템**: 플레이어의 선택이 캐릭터의 호감도 같은 데이터에 미치는 영향을 시스템화합니다. **"+10 호감도"** 같은 시각적 피드백과 **관계 진행 막대(Progress Bar)** UI를 통해 플레이어에게 자신의 행동이 관계에 긍정적인 영향을 미치고 있음을 명확하게 인지시킵니다.

  * **하이브리드 데이터베이스**: 대화 기록처럼 기기 내에서만 사용되는 데이터는 \*\*SQLite(로컬 DB)\*\*에, 여러 기기에서 동기화가 필요한 계정 정보는 \*\*Firebase(클라우드 DB)\*\*에 저장하는 방식으로 데이터의 성격에 맞게 저장소를 분리하여 안정성과 효율성을 확보합니다.

-----

### 4\. UX 및 라이브 운영: 몰입감과 지속 가능한 성장

이 파트는 AI 캐릭터에 생명력을 불어넣고, 출시 이후에도 서비스를 안정적으로 운영하며 지속적으로 개선하기 위한 기술들을 다룹니다.

  * **동적 립싱크 시스템**: LLM이 생성한 텍스트를 음성(TTS)으로 변환하고, **uLipSync** 플러그인을 이용해 음성 파형을 실시간으로 분석하여 캐릭터 모델의 **입 모양(블렌드 셰이프)을 동기화**합니다. 캐릭터가 실제로 말하는 듯한 느낌을 주어 **몰입감을 극대화**하는 핵심 UX 기술입니다.

  * **CI/CD 파이프라인**: **GitHub Actions**를 활용해 코드 변경사항이 저장소에 반영될 때마다 **빌드와 배포 과정을 자동화**합니다. 이를 통해 버그 수정이나 새로운 콘텐츠 업데이트를 사용자에게 빠르고 안정적으로 전달할 수 있습니다.

  * **AI 피드백 루프**: **Firebase Analytics**로 AI 응답에 대한 플레이어의 피드백(예: 좋아요/싫어요) 데이터를 수집하고, 분석 결과를 바탕으로 RAG 데이터베이스나 프롬프트를 수정하여 AI의 성능을 개선합니다. 이는 플레이어와의 상호작용을 통해 **AI 캐릭터가 스스로 학습하고 성장**하게 만드는 장기적인 운영의 핵심입니다.

-----

### 5\. 프로젝트 기술 스택 학습 가이드

각 기술을 효율적으로 학습하기 위한 추천 자료 목록입니다. 공식 문서로 기본 개념을 잡고, 튜토리얼과 강의로 실습하며, 커뮤니티에서 실제 사례를 참고하는 순서로 공부하는 것을 추천합니다.

#### **AI 코어 아키텍처**

  * **Gemini API**
      * **공식 문서**: [Google AI for Developers](https://ai.google.dev/docs) (가장 정확하고 기본적인 정보)
      * **빠른 시작 가이드**: [Gemini API C\# Quickstart](https://www.google.com/search?q=https://ai.google.dev/docs/csharp_quickstart) (C\# 환경에서 API를 사용하는 첫걸음)
  * **RAG 및 프롬프트 엔지니어링**
      * **개념 학습**: [Google Cloud의 RAG 설명](https://cloud.google.com/use-cases/retrieval-augmented-generation?hl=ko) (RAG가 왜 필요한지 이해하기)
      * **온라인 강의**: [DeepLearning.AI의 RAG 강의](https://www.deeplearning.ai/short-courses/langchain-for-llm-application-development/) (LangChain을 활용한 RAG 시스템 구축 심화 학습)
      * **프롬프트 가이드**: [Google의 프롬프트 디자인 가이드](https://www.google.com/search?q=https://cloud.google.com/vertex-ai/docs/generative-ai/learn/prompt-design)

#### **클라이언트 구현**

  * **Unity C\# 기초**
      * **공식 학습 플랫폼**: [Unity Learn](https://learn.unity.com/) (유니티 엔진과 C\#의 모든 것을 배울 수 있는 최고의 자료)
      * **추천 도서**: "Head First C\#" (프로그래밍 입문자에게 추천)
  * **UniTask (비동기 처리)**
      * **공식 GitHub**: [Cysharp/UniTask](https://github.com/Cysharp/UniTask) (가장 정확한 사용법과 예제 코드)
      * **소개 영상**: Unity 비동기 프로그래밍 관련 유튜브 튜토리얼 검색
  * **VContainer (의존성 주입)**
      * **공식 문서**: [VContainer 공식 사이트](https://vcontainer.hadashikick.jp/) (설치부터 사용법까지 상세히 설명)
      * **튜토리얼 영상**: [유니티 VContainer 기초 강좌](https://www.youtube.com/watch?v=17U3bLkFgEU) (영문이지만 개념을 시각적으로 이해하기 좋음)

#### **게임플레이 시스템**

  * **ScriptableObject**
      * **공식 매뉴얼**: [Unity 매뉴얼 - ScriptableObject](https://docs.unity3d.com/kr/current/Manual/class-ScriptableObject.html)
      * **심화 학습**: [Unity 공식 - ScriptableObject를 활용한 아키텍처 설계](https://unity.com/how-to/architect-game-code-scriptable-objects)
  * **Firebase & SQLite**
      * **Firebase 공식 문서**: [Unity용 Firebase 시작하기](https://firebase.google.com/docs/unity/setup?hl=ko) (가장 신뢰할 수 있는 가이드)
      * **SQLite 튜토리얼**: [Unity SQLite 연동 블로그](https://wergia.tistory.com/177) (사진과 함께 따라 하기 쉬운 가이드)

#### **UX 및 라이브 운영**

  * **uLipSync**
      * **공식 GitHub**: [hecomi/uLipSync](https://github.com/hecomi/uLipSync) (설치법과 기본 사용법, 샘플 프로젝트 제공)
  * **CI/CD (GitHub Actions)**
      * **공식 가이드**: [GameCI - Unity용 CI/CD 문서](https://game.ci/docs/) (가장 표준적인 유니티 CI/CD 설정 방법)
      * **튜토리얼**: [GitHub Actions로 Unity 빌드 자동화하기](https://dev.to/virtualmaker/automating-unity-builds-with-github-actions-1inf) (따라 하기 쉬운 블로그 글)
  * **Firebase Analytics**
      * **공식 문서**: [Unity에서 애널리틱스 이벤트 로깅](https://firebase.google.com/docs/analytics/unity/events?hl=ko)