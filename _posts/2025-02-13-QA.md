---
categories: graphics
tags: [graphics, opengl, qa, tutorial]
toc: true
toc_sticky: true
author_profile: false
use_math: true
thumbnail: https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTf6c44cGdSVe9jPWgeQWwXyCdwjADxP6NrLA&s
---
# Q&A : 그래픽스 프로그래밍 기초: Window, Triangle, Camera 

이 글에서는 OpenGL을 사용해 그래픽스 프로그래밍에 입문하면서 마주칠 수 있는 기본적인 질문들에 대해 다룬다. `glad` 헤더 포함 순서부터 시작해 OpenGL의 핵심 개념인 Context, 셰이더, 그리고 카메라 제어까지 차근차근 알아보자.

-----

## 윈도우 생성 (Hello Window)

### 왜 `glad`를 먼저 `#include` 해야 하는가?

**핵심은 컴파일 단계에서 OpenGL 함수 포인터를 정의하는 문제 때문이다.**

`glad`를 `glfw`보다 먼저 포함하지 않으면, `glad`가 OpenGL 함수 포인터를 제대로 정의하지 못해 컴파일 에러가 발생할 수 있다. 그 이유는 다음과 같다.

1.  **GLFW의 내부 동작**: `GLFW/glfw3.h` 파일은 OpenGL과 연동하기 위해 내부적으로 OpenGL 관련 헤더(`GL/gl.h` 등)를 포함한다. 만약 `glfw`를 먼저 포함하면, 기본 OpenGL 헤더가 먼저 포함되는데, 이 헤더는 최신 OpenGL 함수들을 선언만 할 뿐, 실제 함수 포인터를 정의하지 않는다.

2.  **GLAD의 역할**: `glad`는 특정 버전의 OpenGL 함수 포인터를 찾아 정의하고 초기화하는 코드를 생성해주는 라이브러리다. `glad`가 먼저 포함되어야 올바른 함수 포인터가 정의되고, 이후에 포함되는 `glfw`가 이를 그대로 사용하게 된다.

3.  **컴파일 순서의 중요성**: `glfw`가 먼저 포함되면 `glad`가 필요한 정의를 덮어쓰지 못할 수 있다. 결과적으로 `glClear`, `glViewport` 같은 OpenGL 함수를 호출할 때, 컴파일러는 해당 함수를 찾지 못해 'undefined reference' 에러를 발생시킨다.

결론적으로, **`glad`는 항상 `glfw`보다 먼저 포함해야 한다.** 이는 컴파일 시점의 문제를 예방하기 위한 중요한 규칙이다.

-----

### OpenGL Context란 무엇인가?

**Context란 OpenGL의 모든 상태와 동작을 관리하는 하나의 환경이다.** OpenGL은 **상태 기반(State-based) API**이므로, 모든 명령은 현재 활성화된 Context 내에서 실행된다.

Context가 담고 있는 정보는 다음과 같다.

  * **렌더링 상태**: 뷰포트, 컬러 버퍼, 깊이 버퍼, 스텐실 버퍼 등.
  * **연결된 리소스**: 셰이더 프로그램, 텍스처, VAO(Vertex Array Object) 등.
  * **렌더링 옵션**: 렌더링 동작을 제어하는 각종 설정.

`glfwCreateWindow` 함수는 창(Window)과 함께 이 Context를 생성한다. 하지만 생성만으로는 부족하며, `glfwMakeContextCurrent(window)` 함수를 호출해야 해당 Context가 "현재 사용 중인 작업 공간"으로 설정된다. 이 과정이 없으면 어떤 OpenGL 명령도 동작하지 않는다.

-----

### `glfwMakeContextCurrent` 와 `glfwSetFramebufferSizeCallback` 호출 시점

```cpp
glfwMakeContextCurrent(window);
glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
```

위 두 함수는 창 생성 직후에 호출되는 것이 일반적이다.

1.  **`glfwMakeContextCurrent(window)`**: OpenGL 명령을 실행하려면 반드시 활성화된 Context가 필요하다. **GLAD 로딩, 셰이더 생성 등 모든 OpenGL 초기화 작업은 Context가 활성화된 후에만 가능하다.** 따라서 다른 OpenGL 관련 함수를 호출하기 전에 가장 먼저 이 함수를 호출해야 한다.

2.  **`glfwSetFramebufferSizeCallback(window, framebuffer_size_callback)`**: 이 함수는 창 크기가 변경될 때마다 특정 함수(콜백 함수)를 호출하도록 등록하는 역할을 한다. 창 크기 변경 이벤트는 GLFW가 관리하므로, `window` 객체와 연결된 Context가 활성화된 상태에서 설정해야 콜백 함수가 정상적으로 동작하고, 콜백 함수 내에서 `glViewport` 같은 OpenGL 함수를 호출할 때 문제가 발생하지 않는다.

-----

### 렌더 루프: `processInput`과 `glfwPollEvents`의 관계

렌더링 루프 안에서 두 함수는 상호 보완적인 역할을 한다.

  * `**processInput(window)**`: 사용자가 정의한 입력 처리 함수다. 예제에서는 `glfwGetKey`를 사용해 ESC 키가 눌렸는지 확인하고, 눌렸다면 창을 닫도록 `glfwSetWindowShouldClose`를 호출한다. 즉, **특정 입력에 대한 구체적인 로직**을 담당한다.

  * `**glfwPollEvents()**`: 키보드, 마우스 움직임, 창 크기 변경 등 GLFW가 감지한 **모든 이벤트를 수집하고 처리**하는 함수다. GLFW는 내부적으로 이벤트 큐(Queue)를 가지고 있으며, 이 함수가 호출될 때 큐에 쌓인 이벤트를 처리하고 등록된 콜백 함수들을 실행한다.

**두 함수의 관계**
`glfwPollEvents()`가 호출되어야만 GLFW가 키보드 입력을 감지하고 이벤트 큐에 넣을 수 있다. 따라서 `processInput` 함수가 `glfwGetKey`를 통해 키 상태를 확인하려면, 그전에 반드시 `glfwPollEvents()`가 호출되어 이벤트가 처리되어야 한다.

> **요약**: `glfwPollEvents()`가 운영체제로부터 모든 이벤트를 받아와 처리하고, `processInput`은 그중 특정 키보드 입력에 대한 사용자 정의 동작을 수행한다.

-----

## 삼각형 그리기 (Hello Triangle)

### 셰이더 코드는 왜 문자열로 작성하는가?

셰이더는 **GPU에서 직접 실행되는 작은 프로그램**이며, \*\*GLSL(OpenGL Shading Language)\*\*이라는 언어로 작성된다. C++ 코드 내에서 셰이더 코드를 문자열로 작성하는 이유는 OpenGL API가 셰이더 소스 코드를 문자열 형태로 전달받기 때문이다.

```glsl
const char *vertexShaderSource = "#version 330 core\n"
    "layout (location = 0) in vec3 aPos;\n"
    "void main()\n"
    "{\n"
    "   gl_Position = vec4(aPos, 1.0);\n"
    "}\0";
```

  * `**#version 330 core**`: 사용할 GLSL 버전을 명시한다. 여기서는 OpenGL 3.3의 Core Profile을 사용한다는 의미다.
  * `**layout (location = 0) in vec3 aPos;**`: 정점 데이터를 입력받는 변수를 정의한다.
      * `layout (location = 0)`: 이 변수가 정점 데이터의 0번째 속성(attribute)에 해당함을 명시한다.
      * `in vec3 aPos`: `aPos`라는 이름의 3차원 벡터(`vec3`)를 입력으로 받는다.
  * `**gl_Position = vec4(aPos, 1.0);**`: 정점 셰이더의 최종 출력이다. 입력받은 정점 위치 `aPos`를 4차원 \*\*동차 좌표(homogeneous coordinate)\*\*로 변환하여 OpenGL 내장 변수인 `gl_Position`에 저장한다. 이 값은 이후 렌더링 파이프라인에서 최종 화면 좌표로 변환된다.
  * `**\0**`: 문자열의 끝을 알리는 널(null) 문자다. C 스타일 문자열에서는 필수적이다.

-----

### 여러 VAO를 사용할 때 언바인딩이 불필요한 이유

**새로운 VAO를 바인딩하면 이전에 바인딩된 VAO는 자동으로 비활성화되기 때문이다.**

OpenGL에서는 한 번에 하나의 VAO(Vertex Array Object)만 활성 상태가 될 수 있다. `glBindVertexArray(vao1)`을 호출하면 VAO 1이 활성화되고 모든 정점 관련 설정은 여기에 저장된다.

이후에 `glBindVertexArray(vao2)`를 호출하면, **VAO 1은 자동으로 비활성화되고 VAO 2가 새롭게 활성화된다.** 따라서 아래와 같이 코드를 작성할 수 있다.

```cpp
// 비효율적인 방식
glBindVertexArray(vao1);
// ... vao1 설정 ...
glBindVertexArray(0); // vao1 언바인딩 (불필요)
glBindVertexArray(vao2);
// ... vao2 설정 ...

// 효율적인 방식
glBindVertexArray(vao1);
// ... vao1 설정 ...
glBindVertexArray(vao2); // vao1은 자동으로 비활성화되고 vao2가 활성화됨
// ... vao2 설정 ...
```

`glBindVertexArray(0)`을 호출하여 명시적으로 언바인딩하는 경우는, 모든 VAO 설정을 마친 후 의도치 않은 변경을 막거나, 모든 VAO를 비활성화해야 하는 특별한 상황에만 필요하다.

-----

### 데이터는 어떻게 셰이더로 전달되는가?

CPU에 있는 정점 데이터가 GPU의 셰이더 프로그램으로 전달되는 과정은 다음과 같다.

1.  **`glBufferData`**: **CPU의 메모리에 있는 정점 데이터(`vertices` 배열 등)를 GPU 메모리의 버퍼 객체(VBO)로 전송한다.** 이 단계는 데이터를 GPU로 "업로드"하는 과정이다.

2.  **`glVertexAttribPointer`**: **GPU에 전송된 데이터가 셰이더의 어떤 입력 변수(attribute)에 해당되는지 연결해준다.** 이 함수는 현재 바인딩된 VAO에 이 연결 정보를 저장한다.

      * 예를 들어, `glVertexAttribPointer(0, ...)`는 VBO의 데이터가 셰이더의 `layout (location = 0)`으로 지정된 `aPos` 변수와 연결됨을 OpenGL에 알려준다.

3.  **셰이더 실행**: 렌더링 명령이 호출되면 GPU는 현재 바인딩된 VAO의 설정에 따라 VBO로부터 데이터를 가져와 셰이더를 실행한다.

      * **정점 셰이더**는 `aPos` 같은 변수로 정점 데이터를 받아 위치를 변환(`gl_Position`)한다.
      * **프래그먼트 셰이더**는 정점 셰이더의 출력을 보간(interpolate)하여 최종 픽셀의 색상을 계산한다.

> **데이터 흐름 요약**
> `CPU의 데이터` → `glBufferData` → `GPU 버퍼(VBO)` → `glVertexAttribPointer`로 연결 → `셰이더 프로그램`에서 사용

-----

## 카메라 제어 (Camera)

### 오일러 각: 왜 `cos(yaw)`와 `cos(pitch)`를 곱하는가?

카메라의 방향 벡터(`direction`)를 계산할 때 yaw(좌우 회전)와 pitch(상하 회전) 값을 모두 사용해야 한다. `direction.x`를 계산하는 코드는 다음과 같다.

`direction.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));`

여기서 두 코사인 값을 곱하는 이유는 **pitch 각도에 따라 수평 방향 벡터의 크기를 조절하기 위함이다.**

  * `**cos(yaw)**`: XZ 평면(수평면)에서의 카메라 방향을 결정한다. yaw가 0일 때 `cos(0) = 1`로, X축 방향 성분이 최대가 된다.
  * `**cos(pitch)**`: 상하 방향을 고려해 수평 성분을 보정하는 역할을 한다.
      * **pitch = 0° (정면)**: `cos(0) = 1`이므로, `cos(yaw)` 값이 그대로 `direction.x`에 반영된다.
      * **pitch = 90° (수직 위)**: `cos(90) = 0`이므로, `direction.x`는 0이 된다. 카메라가 하늘을 보면 수평 이동 성분은 없어져야 하므로 이는 올바른 계산이다.
      * **pitch = -90° (수직 아래)**: `cos(-90) = 0`이므로, 위와 마찬가지로 `direction.x`는 0이 된다.

결론적으로, **`cos(pitch)`를 곱하는 것은 카메라가 위나 아래를 볼수록 수평(X, Z) 방향으로의 이동량을 점차 줄여, 최종 방향 벡터를 올바르게 계산하기 위함이다.**

-----

### 마우스 오프셋 계산 순서가 다른 이유

마우스 움직임에 따른 `xoffset`과 `yoffset`의 계산 방식이 다른 이유는 **GLFW의 Y축 좌표계 방향 때문이다.**

```cpp
float xoffset = xpos - lastX;
float yoffset = lastY - ypos; // ypos - lastY가 아님
```

1.  **GLFW 좌표계**: 화면의 **왼쪽 아래** 모서리가 원점 `(0, 0)`이다. X축은 오른쪽으로 갈수록, Y축은 **위로 갈수록** 증가한다.

2.  **일반적인 윈도우 좌표계**: 화면의 **왼쪽 위** 모서리가 원점 `(0, 0)`이다. Y축은 **아래로 갈수록** 증가한다.

3.  **xoffset 계산**: 마우스를 오른쪽으로 움직이면 `xpos`가 `lastX`보다 커지므로 `xoffset`은 양수가 된다. 이는 GLFW의 X축 방향과 일치하므로 `xpos - lastX`가 맞다.

4.  **yoffset 계산**: 마우스를 위로 움직이면 화면 좌표계 기준으로는 y값이 감소하지만, GLFW 좌표계 기준으로는 `ypos` 값이 `lastY`보다 **커진다.** 만약 `ypos - lastY`로 계산하면 마우스를 위로 움직였을 때 `yoffset`이 양수가 되어 카메라가 아래를 보게 된다. 우리가 원하는 것은 카메라가 위를 보는 것이므로, Y축의 방향을 뒤집어주기 위해 `lastY - ypos`로 계산하여 부호를 반전시키는 것이다.